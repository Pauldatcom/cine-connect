# CinéConnect - Cursor Rules

# Project: Collaborative movie platform (Letterboxd-inspired)

# Deadline: March 25, 2026

## LANGUAGE POLICY (STRICT)

**ENGLISH ONLY. NO EXCEPTIONS.**

- All code comments: English
- All variable/function names: English
- All documentation: English
- All commit messages: English
- All responses from AI: English
- NO French anywhere in the codebase

## TESTING POLICY (MANDATORY)

**100% CODE COVERAGE + E2E TESTS REQUIRED for frontend AND backend.**

### Rules:

1. Every new component MUST have a corresponding `.test.tsx` file
2. Every new API route MUST have a corresponding `.test.ts` file
3. Every new utility function MUST have unit tests
4. Every new hook MUST have tests
5. Every new **FEATURE** MUST have E2E tests in `e2e/` folder
6. NO code is considered complete without tests
7. Run `pnpm test:coverage` before any PR
8. Run `pnpm test:e2e` before any PR for features

### Test File Naming:

- Component: `FilmPoster.tsx` → `FilmPoster.test.tsx`
- Route: `auth.ts` → `auth.test.ts`
- Utility: `utils.ts` → `utils.test.ts`

### Test Location:

- Frontend tests: Same folder as component OR `frontend/src/__tests__/`
- Backend tests: Same folder as module OR `backend/src/__tests__/`
- E2E tests: `e2e/` folder at project root

### E2E Testing (Playwright)

All user-facing features require E2E tests:

```
e2e/
├── auth.spec.ts         # Registration, login, logout, session
├── films.spec.ts        # Browse, search, film details, categories
├── reviews.spec.ts      # Create/view reviews, ratings
├── chat.spec.ts         # Discussion page, messages
└── user-journey.spec.ts # Full user flow integration
```

**E2E Commands:**

- `pnpm test:e2e` - Run all E2E tests headless
- `pnpm test:e2e:headed` - Run with visible browser
- `pnpm test:e2e:ui` - Interactive Playwright UI
- `SKIP_WEBSERVER=true pnpm test:e2e` - Use existing dev servers

**When to Add E2E Tests:**

- New user-facing feature (new route, new interaction)
- Changes to auth flow
- Changes to critical user journeys
- New Socket.io features

**E2E Test Best Practices:**

- Use `getByRole`, `getByLabel`, `getByText` for accessibility
- Use `{ exact: true }` to avoid strict mode violations
- Use `.first()` when multiple elements match
- Use timeouts for async operations (15s for auth, 10s for data)
- Test happy path AND error states

### Coverage Thresholds (vitest.config.ts):

```typescript
coverage: {
  provider: 'v8',
  reporter: ['text', 'html', 'lcov'],
  thresholds: {
    statements: 100,
    branches: 100,
    functions: 100,
    lines: 100,
  },
}
```

## PROJECT CONTEXT

This is a full-stack school project evaluated on 100 points across 4 modules:

- React (25 pts): Frontend architecture, TanStack Router, API integration
- UI/Design (10 pts): Aesthetics, responsive, accessibility, dark/light mode
- Database (15 pts): PostgreSQL schema, Drizzle ORM, migrations
- Node.js/Backend (35 pts): REST API, JWT, WebSocket, Swagger, tests
- Collaboration (10 pts): GitHub workflow, branches, documentation
- Writing (5 pts): README, technical coherence

## MONOREPO STRUCTURE (STRICT)

```
cine-connect/
├── frontend/          # React app (DO NOT rename)
├── backend/           # Node.js API (DO NOT rename)
├── shared/            # Shared types/constants (DO NOT rename)
└── docs/              # Documentation, schemas
```

## REQUIRED TECH STACK (NON-NEGOTIABLE)

### Frontend

- React.js with TypeScript
- TanStack Router (file-based routing)
- TanStack Query (data fetching)
- TailwindCSS (styling)
- Vite (bundler)
- Vitest + React Testing Library (testing)

### Backend

- Node.js + Express
- Drizzle ORM (NOT Prisma, NOT TypeORM)
- JWT authentication (jsonwebtoken)
- Socket.io (real-time chat)
- Swagger (API documentation)
- Vitest + Supertest (testing)

### Database

- PostgreSQL (via Docker)
- Required tables: users, films, categories, reviews, messages, friends

### Tools

- pnpm (package manager)
- Vitest (testing)
- Git with feature branches

## CLEAN ARCHITECTURE (Backend)

The backend follows Clean Architecture principles with proper separation of concerns:

### Layer Structure

1. **Domain Layer** (`src/domain/`)
   - `entities/` - Pure domain models (User, Film, Review, etc.)
   - `repositories/` - Repository interfaces (IUserRepository, IFilmRepository, etc.)
   - No framework dependencies

2. **Application Layer** (`src/application/`)
   - `use-cases/` - Business logic (CreateReviewUseCase, LikeReviewUseCase, etc.)
   - Depends only on domain layer
   - Injectable via tsyringe

3. **Infrastructure Layer** (`src/infrastructure/`)
   - `repositories/` - Drizzle ORM implementations (DrizzleUserRepository, etc.)
   - `container.ts` - Dependency injection setup
   - Implements domain interfaces

4. **Presentation Layer** (`src/routes/`, `src/middleware/`, `src/socket/`)
   - Express routes handle HTTP concerns only
   - Delegate business logic to use cases
   - Socket handlers for real-time features

### Rules

- Business logic MUST be in use cases, NOT in routes
- Routes should only: parse input, call use case, format response
- Repository interfaces define contracts, implementations handle DB
- Use tsyringe for dependency injection
- Domain entities are framework-agnostic

## FRONTEND ARCHITECTURE

### Component Organization

```
components/
├── layout/           # App layout (Navbar, Footer)
├── ui/               # Generic, reusable (StarRating, FilterPanel)
├── features/         # Domain-specific (FilmCard, ReviewCard, ReviewForm)
└── ProtectedRoute.tsx
```

**Rules:**

- `ui/` = Pure presentational, no business logic, highly reusable
- `features/` = Domain-aware, knows about films/reviews/users
- Never import from routes into components

### Custom Hooks Pattern

All hooks in `src/hooks/`:

```typescript
// Naming: use{Domain}{Action}
useFilm(tmdbId); // Single film
useFilmCredits(tmdbId); // Film credits
useFilmReviews(filmId); // Reviews for film
useCreateReview(); // Mutation hook
useLikeReview(); // Mutation hook
```

**Hook Rules:**

- Return `{ data, isLoading, error }` for queries
- Return `{ mutate, isPending }` for mutations
- Encapsulate all TanStack Query logic
- Export from `hooks/index.ts`

### API Layer

All API clients in `src/lib/api/`:

```
lib/api/
├── client.ts         # Base fetch wrapper + token handling
├── auth.ts           # Auth endpoints
├── films.ts          # Film endpoints (backend)
├── reviews.ts        # Review endpoints
└── tmdb.ts           # TMDb API integration
```

**Rules:**

- Keep API functions pure (just fetch + return)
- Hooks wrap API functions with TanStack Query
- Never call API directly from components, use hooks

### Type Centralization

Frontend-specific types in `src/types/index.ts`:

```typescript
// Re-export shared types
export type { User, Film, Review } from '@cine-connect/shared';

// Frontend-specific
export interface FilmWithCredits { ... }
export interface Conversation { ... }
```

## REQUIRED ROUTES (Frontend)

MUST implement these exact routes:

- `/` - Home page
- `/films` - Film listing with filters
- `/films/:categorie` - Films by category
- `/film/:id` - Single film detail
- `/profil` - User profile / Auth
- `/discussion` - Real-time chat

## CODING STANDARDS

### TypeScript

- Use strict mode
- Define interfaces in `shared/src/types/`
- Export shared types from `@cine-connect/shared`

### React Components

- Functional components only
- Use TanStack Query for ALL API calls
- File naming: PascalCase for components, camelCase for utilities

### API Endpoints Pattern

- Base: `/api/v1/`
- Auth: `/api/v1/auth/register`, `/api/v1/auth/login`
- Resources: `/api/v1/users`, `/api/v1/films`, `/api/v1/reviews`, etc.
- Document ALL endpoints with Swagger JSDoc comments

### Database Schema

- Use UUID for all primary keys
- Include created_at, updated_at on all tables
- Define relations with Drizzle relations()

## DESIGN REQUIREMENTS

### Letterboxd-Inspired Theme

- Primary background: #14181c (dark)
- Secondary: #1c2228
- Accent green: #00e054
- Accent orange: #ff8000
- Text muted: #9ab

### UI Requirements

- Dark mode by default (light mode optional)
- Fully responsive (mobile-first)
- Accessible (aria labels, semantic HTML)
- Smooth animations (Tailwind transitions)

## API INTEGRATION

### TMDb API (Primary)

- Use for: posters, backdrops, cast, trailers, genres
- Image base: https://image.tmdb.org/t/p/
- Poster sizes: w185, w342, w500, original
- Backdrop sizes: w300, w780, w1280, original

### Backend API

- Use for: auth, user data, reviews, messages, friends
- Always return { success: boolean, data?: T, error?: string }

## SOCKET.IO EVENTS

Required events for chat:

- `connect` / `disconnect`
- `message` - Send/receive messages
- `typing` - Typing indicator
- `online` - User online status
- `join_room` / `leave_room`

## GIT WORKFLOW

- Main branch: `main` (production-ready)
- Feature branches: `feature/feature-name`
- Never commit directly to main
- Write meaningful commit messages (in English)

## TESTING REQUIREMENTS (CRITICAL)

### Coverage: 100% MANDATORY

- Statements: 100%
- Branches: 100%
- Functions: 100%
- Lines: 100%

### When Adding Code:

1. Write the test FIRST (TDD preferred)
2. Or write test IMMEDIATELY after the code
3. Never commit code without tests
4. Run `pnpm test:coverage` to verify

### What to Test:

**Frontend:**

- Component rendering
- User interactions (clicks, inputs)
- API call mocking with MSW or vitest mocks
- Error states
- Loading states
- Route navigation

**Backend:**

- API endpoint responses
- Authentication/authorization
- Database operations (with test DB)
- Error handling
- Socket.io events

## DOCUMENTATION

### Required

- README.md at root (project overview, setup)
- Swagger at /api-docs (backend)
- JSDoc comments on complex functions

### Report (2-3 pages)

- Architecture overview
- Team role distribution
- Technical choices justification

## PRE-COMMIT CHECKLIST (MANDATORY)

**Before ANY commit or push, run ALL checks:**

```bash
# Required for every commit:
pnpm lint && pnpm typecheck && pnpm test

# Required for feature PRs:
pnpm test:e2e
```

### Why This Matters:

1. **`pnpm lint`** - Catches code style issues and ESLint errors
2. **`pnpm typecheck`** - Catches TypeScript strict mode errors (CI runs this!)
3. **`pnpm test`** - Ensures tests pass at runtime

### Common TypeScript Pitfalls:

1. **Mock type casting** - Always use `as unknown as` for mock types:

   ```typescript
   // ❌ WRONG - strict mode rejects this
   const mockApi = api as { get: Mock };

   // ✅ CORRECT - double assertion
   const mockApi = api as unknown as { get: Mock };
   ```

2. **Array access** - Use non-null assertion when certain element exists:

   ```typescript
   // ❌ WRONG - TypeScript says could be undefined
   await user.click(buttons[0]);

   // ✅ CORRECT - assert it exists
   await user.click(buttons[0]!);
   ```

3. **Optional properties** - Always handle undefined cases or assert

**NEVER push code that hasn't passed all three checks locally.**

## COMMON ERRORS TO AVOID

1. DON'T use `packages/` folder - use flat structure
2. DON'T mix OMDb and TMDb - pick one (we use TMDb)
3. DON'T skip Swagger documentation
4. DON'T hardcode API keys - use .env
5. DON'T forget to handle loading/error states
6. DON'T create components without TypeScript props interface
7. DON'T write code without tests
8. DON'T use French anywhere
9. DON'T commit with coverage below 100%
10. DON'T push without running `pnpm lint && pnpm typecheck && pnpm test`

## EVALUATION CHECKLIST

Before each submission, verify:

### React Module

- [ ] TanStack Router with all 6 routes
- [ ] TanStack Query for API calls
- [ ] Film cards, navigation, filters
- [ ] Clean component structure
- [ ] 100% test coverage

### UI Module

- [ ] TailwindCSS styling
- [ ] Responsive design (test on mobile)
- [ ] Dark/light mode toggle
- [ ] Consistent typography & spacing

### Database Module

- [ ] PostgreSQL with Docker
- [ ] Drizzle schema with relations
- [ ] Migrations working
- [ ] All 6 tables implemented

### Backend Module

- [ ] Express REST API
- [ ] JWT auth (register/login)
- [ ] Socket.io chat working
- [ ] Swagger documentation complete
- [ ] 100% test coverage

## IMPORTS CONVENTION

```typescript
// React/External libs first
import { useState, useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Link } from '@tanstack/react-router';

// Shared package
import { User, Film } from '@cine-connect/shared';

// Local imports (use @/ alias)
import { FilmPoster } from '@/components/FilmPoster';
import { getMovieDetails } from '@/lib/api/tmdb';
```

## FILE CREATION RULES

When creating new files:

1. Frontend components → `frontend/src/components/` (code) + `frontend/src/__tests__/components/` (tests)
2. Frontend routes → `frontend/src/routes/` (TanStack file-based)
3. API clients → `frontend/src/lib/api/` (code) + `frontend/src/__tests__/lib/api/` (tests)
4. Frontend hooks → `frontend/src/hooks/` (code) + `frontend/src/__tests__/hooks/` (tests)
5. Backend routes → `backend/src/routes/` (code) + `backend/src/__tests__/integration/` (tests)
6. Backend domain → `backend/src/domain/` (code) + `backend/src/__tests__/unit/domain/` (tests)
7. Backend use cases → `backend/src/application/` (code) + `backend/src/__tests__/unit/application/` (tests)
8. Database schema → `backend/src/db/schema/`
9. Shared types → `shared/src/types/`
10. E2E tests → `e2e/` (root level, all Playwright tests)

## TEST ARCHITECTURE

**All tests live in `__tests__/` directories that mirror the source structure.**

### Backend Test Structure

```
backend/src/__tests__/
├── unit/                      # Unit tests (isolated, mocked dependencies)
│   ├── domain/entities/       # Domain entity tests
│   ├── application/use-cases/ # Use case tests
│   ├── middleware/            # Middleware tests
│   └── config/                # Config tests
├── integration/               # Integration tests (API routes, socket)
├── setup.ts                   # Test setup/config
└── mocks/                     # Shared mocks and fixtures
```

### Frontend Test Structure

```
frontend/src/__tests__/
├── components/
│   ├── ui/                    # Generic UI component tests
│   ├── features/              # Feature component tests
│   └── layout/                # Layout component tests
├── hooks/                     # Custom hook tests
├── contexts/                  # Context tests
├── lib/api/                   # API client tests
├── routes/                    # Route component tests
├── setup.ts                   # Test setup/config
├── test-utils.tsx             # Custom render, providers
└── mocks/                     # Shared mocks and fixtures
```

### E2E Test Structure

```
e2e/                           # Playwright E2E tests (root level)
├── auth.spec.ts               # Authentication flows
├── films.spec.ts              # Film browsing/details
├── reviews.spec.ts            # Review creation/interaction
├── chat.spec.ts               # Real-time chat features
└── user-journey.spec.ts       # Full user journey tests
```

## E2E TESTING REQUIREMENTS

**Every new feature MUST include E2E tests.**

### E2E Test Best Practices

1. Wait for API responses using `Promise.all` with `waitForResponse`
2. Use specific selectors (prefer `getByRole`, `getByLabel`, avoid generic text)
3. Test the happy path AND error cases
4. Use test helpers for common actions (login, registration)
5. Add appropriate timeouts for async operations

### Running E2E Tests

```bash
# Start servers manually first, then:
SKIP_WEBSERVER=true pnpm test:e2e

# Or let Playwright start servers:
pnpm test:e2e

# Headed mode for debugging:
SKIP_WEBSERVER=true pnpm test:e2e:headed
```

## RESPONSE LANGUAGE

**ENGLISH ONLY.**

- All AI responses must be in English
- All code must be in English
- All comments must be in English
- No French, no exceptions
